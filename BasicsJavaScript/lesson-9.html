<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Операторы сравнения и логические значения</title>
</head>
<body>
 <h3>Логические значения</h3>
 <ul>
     <li>true – имеет смысл «да», «верно», «истина»</li>
     <li>false – означает «нет», «неверно», «ложь»</li>
 </ul>

 <h3>Сравнение строк</h3>
 <p><strong>Строки сравниваются побуквенно</strong></p>

 <p><strong>В кодировке Unicode обычно код у строчной буквы больше, чем у прописной.</strong></p>

 <h3>Сравнение разных типов</h3>

 <h3>Строгое равенство</h3>
 <p><strong>Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==.</strong></p>

 <h3>Сравнение с null и undefined</h3>

 <p><strong>Интуитивно кажется, что null/undefined эквивалентны нулю, но это не так.</strong></p>

 <ul>
     <li>Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.</li>
     <li>При преобразовании в число null становится 0, а undefined становится NaN.</li>
 </ul>

 <h3>Некорректный результат сравнения null с 0</h3>
 <p>Как такое возможно? Если нечто «больше или равно нулю», то резонно полагать, что оно либо больше, либо равно. Но здесь это не так.

     Дело в том, что алгоритмы проверки равенства == и сравнения >= > < <= работают по-разному.

     Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения null и undefined обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё.

     В результате получается странная с точки зрения здравого смысла ситуация, которую мы видели в примере выше.</p>

 <h3>Несравнимый undefined</h3>

 <ul>
     <li>Сравнения (1) и (2) дают false потому, что undefined при преобразовании к числу даёт NaN. А значение NaN по стандарту устроено так, что
         сравнения ==, <, >, <=, >= и даже === с ним возвращают false.
     </li>
     <li>Проверка равенства (3) даёт false, потому что в стандарте явно прописано, что undefined равно лишь null или себе и ничему другому.</li>
 </ul>

 <p><strong>Вывод: любые сравнения с undefined/null, кроме точного ===, следует делать с осторожностью.</strong></p>

<script>
    "use strict";

</script>

</body>
</html>
